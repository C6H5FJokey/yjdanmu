<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>弹幕预览 - yjdanmu</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            position: relative;
            background: #00000000;
        }

        .subtitle-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .subtitle-item {
            position: absolute;
            white-space: nowrap;
            display: inline-block;
            transform-origin: center;
        }

        .char {
            display: inline-block;
            opacity: 0;
            transform: scale(0);
            white-space: pre;
        }

        .typing {
            animation: subtleShake 2s step-end infinite;
            will-change: transform;
        }

        @keyframes subtleShake {
            0%   { transform: translate(0, 0) scale(1); }
            6.25%  { transform: translate(calc(var(--shake-x) * 0.7),  calc(var(--shake-y) * -0.2)) scale(1); }
            12.5%  { transform: translate(calc(var(--shake-x) * -0.4), calc(var(--shake-y) * 0.6))  scale(1); }
            18.75% { transform: translate(calc(var(--shake-x) * 0.2),  calc(var(--shake-y) * -0.9)) scale(1); }
            25%    { transform: translate(calc(var(--shake-x) * -0.9), calc(var(--shake-y) * -0.1)) scale(1); }
            31.25% { transform: translate(calc(var(--shake-x) * 0.5),  calc(var(--shake-y) * 0.8))  scale(1); }
            37.5%  { transform: translate(calc(var(--shake-x) * -0.1), calc(var(--shake-y) * -0.5)) scale(1); }
            43.75% { transform: translate(calc(var(--shake-x) * 0.9),  calc(var(--shake-y) * 0.3))  scale(1); }
            50%    { transform: translate(calc(var(--shake-x) * -0.6), calc(var(--shake-y) * 0.1))  scale(1); }
            56.25% { transform: translate(calc(var(--shake-x) * 0.1),  calc(var(--shake-y) * 0.9))  scale(1); }
            62.5%  { transform: translate(calc(var(--shake-x) * -0.3), calc(var(--shake-y) * -0.7)) scale(1); }
            68.75% { transform: translate(calc(var(--shake-x) * 0.6),  calc(var(--shake-y) * -0.4)) scale(1); }
            75%    { transform: translate(calc(var(--shake-x) * -0.8), calc(var(--shake-y) * 0.4))  scale(1); }
            81.25% { transform: translate(calc(var(--shake-x) * 0.3),  calc(var(--shake-y) * -0.1)) scale(1); }
            87.5%  { transform: translate(calc(var(--shake-x) * -0.2), calc(var(--shake-y) * 0.2))  scale(1); }
            93.75% { transform: translate(calc(var(--shake-x) * 0.8),  calc(var(--shake-y) * -0.8)) scale(1); }
            100%   { transform: translate(0, 0) scale(1); }
        }

        .fade-out {
            animation: fadeOut var(--fade-duration) forwards !important;
        }

        @keyframes fadeOut {
            to { 
                opacity: 0.0 ;
                transform: rotate(var(--original-rotation, 0deg)) translateY(var(--move-up-distance, -10px));;
            }
        }

        /* 简单的连接状态指示器 */
        .connection-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            color: white;
            z-index: 10000;
        }

        .connected {
            background: #4CAF50;
        }

        .disconnected {
            background: #f44336;
        }

        .connecting {
            background: #ff9800;
        }
    </style>
</head>
<body>
    <div class="subtitle-container" id="subtitleContainer"></div>
    
    <script>
        const DEBUG = new URLSearchParams(window.location.search).get('debug') === '1';

        class AdvancedSubtitleSystem {
            constructor() {
                this.container = document.getElementById('subtitleContainer');
                this.activeSubtitles = new Set();
                this.eventSource = null;

                // 渲染队列：解决浏览器后台积压，回到前台瞬间“爆开显示”
                this.renderConfig = {
                    minDispatchIntervalMs: 160,
                    unlimitedDispatch: false,
                    queueMaxLength: 200,
                    queueMaxAgeMs: 15000,
                    dropOnResume: true
                };
                this.queue = [];
                this.isDraining = false;
                this.lastDispatchAt = 0;
                
                this.defaultConfig = {
                    fontSize: 32,
                    fontFamily: 'Arial, sans-serif',
                    textColor: '#ffffff',
                    strokeColor: '#000000',
                    strokeWidth: 2,
                    typingSpeed: 100,
                    displayDuration: 3000,
                    fadeDuration: 1000,
                    shakeAmplitude: 2,
                    shrinkScale: 0.7,
                    finalOpacity: 0.3,
                    randomTilt: 10,
                    maxLeft: null,
                    maxTop: null
                };
            }

            addSubtitle(text, customConfig = {}) {
                const config = { ...this.defaultConfig, ...customConfig };
                if (DEBUG) console.log('addSubtitle - config:', config);
                
                const subtitleElement = this.createSubtitleElement(text, config);
                
                const position = this.getRandomPosition(text, config);
                subtitleElement.style.left = `${position.x}px`;
                subtitleElement.style.top = `${position.y}px`;
                
                const tilt = (Math.random() - 0.5) * config.randomTilt;
                subtitleElement.style.transform = `rotate(${tilt}deg)`;
                subtitleElement.style.setProperty('--original-rotation', `${tilt}deg`);
                
                this.container.appendChild(subtitleElement);
                this.activeSubtitles.add(subtitleElement);

                this.startTypingEffect(subtitleElement, text, config);
                
                return subtitleElement;
            }

            createSubtitleElement(text, config) {
                const element = document.createElement('div');
                element.className = 'subtitle-item';
                
                element.style.fontSize = `${config.fontSize}px`;
                
                element.style.fontFamily = config.fontFamily;
                element.style.color = config.textColor;
                
                // 创建高质量的字体阴影描边效果
                let shadows = [];
                
                // 使用更密集的角度分布以获得更平滑的描边
                const angleStep = Math.max(15, 360 / Math.max(config.strokeWidth * 8, 8));
                
                // 生成围绕文字的阴影点，形成均匀的描边
                for (let angle = 0; angle < 360; angle += angleStep) {
                    const radian = angle * Math.PI / 180;
                    for (let r = 1; r <= config.strokeWidth; r++) {
                        const offsetX = Math.round(Math.cos(radian) * r);
                        const offsetY = Math.round(Math.sin(radian) * r);
                        // 使用轻微的模糊来平滑边缘
                        shadows.push(`${offsetX}px ${offsetY}px 0.5px ${config.strokeColor}`);
                    }
                }
                
                element.style.textShadow = shadows.join(', ');
                element.style.opacity = '1';
                
                return element;
            }

            startTypingEffect(element, text, config) {
                const chars = [];
                element.innerHTML = '';
                
                for (let i = 0; i < text.length; i++) {
                    const charSpan = document.createElement('span');
                    charSpan.className = 'char';
                    charSpan.textContent = text[i];
                    
                    const shakeX = config.shakeAmplitude * 0.25;
                    const shakeY = config.shakeAmplitude * 0.25;
                    charSpan.style.setProperty('--shake-x', `${shakeX}px`);
                    charSpan.style.setProperty('--shake-y', `${shakeY}px`);
                    
                    element.appendChild(charSpan);
                    chars.push(charSpan);
                }

                let index = 0;
                
                const typeNextChar = () => {
                    if (index < chars.length) {
                        chars[index].style.opacity = '1';
                        chars[index].style.transform = 'scale(1)';
                        chars[index].classList.add('typing');
                        index++;
                        setTimeout(typeNextChar, config.typingSpeed);
                    } else {
                        setTimeout(() => {
                            this.startFadeOut(element, config);
                        }, config.displayDuration);
                    }
                };

                typeNextChar();
            }

            startFadeOut(element, config) {
                element.style.setProperty('--fade-duration', `${config.fadeDuration}ms`);
                element.style.setProperty('--final-opacity', config.finalOpacity.toString());
                element.style.setProperty('--shrink-scale', config.shrinkScale.toString());
                
                element.classList.add('fade-out');
                
                setTimeout(() => {
                    element.remove();
                    this.activeSubtitles.delete(element);
                }, config.fadeDuration);
            }

            getRandomPosition(text, config) {
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                
                const tempDiv = document.createElement('div');
                tempDiv.style.position = 'absolute';
                tempDiv.style.visibility = 'hidden';
                tempDiv.style.fontSize = `${config.fontSize}px`;
                tempDiv.style.fontFamily = config.fontFamily;
                tempDiv.textContent = text;
                document.body.appendChild(tempDiv);
                
                const textWidth = tempDiv.offsetWidth;
                const textHeight = tempDiv.offsetHeight;
                document.body.removeChild(tempDiv);
                
                const maxX = Math.min(screenWidth - textWidth, this.defaultConfig.maxLeft || screenWidth - textWidth);
                const maxY = Math.min(screenHeight - textHeight, this.defaultConfig.maxTop || screenHeight - textHeight);

                return {
                    x: Math.max(0, Math.random() * maxX),
                    y: Math.max(0, Math.random() * maxY)
                };
            }

            updateConfig(newConfig) {
                if (DEBUG) console.log('Updating config:', newConfig);
                
                this.defaultConfig = { ...this.defaultConfig, ...newConfig };
                if (DEBUG) console.log('New defaultConfig:', this.defaultConfig);
            }

            updateRenderConfig(newRenderConfig) {
                if (!newRenderConfig) return;
                this.renderConfig = { ...this.renderConfig, ...newRenderConfig };
                if (DEBUG) console.log('Updating renderConfig:', this.renderConfig);
                // 配置变更后尝试继续 drain
                this.drainQueue();
            }

            enqueueDanmu(text, config, meta = {}) {
                const now = Date.now();
                const serverTime = typeof meta.serverTime === 'number' ? meta.serverTime : now;
                this.queue.push({ text, config, serverTime, enqueuedAt: now });

                const maxLen = Number(this.renderConfig.queueMaxLength || 0);
                    if (maxLen > 0 && this.queue.length > maxLen) {
                    // 丢弃最旧
                    this.queue.splice(0, this.queue.length - maxLen);
                }

                this.drainQueue();
            }

            dropExpiredInQueue() {
                const maxAge = Number(this.renderConfig.queueMaxAgeMs || 0);
                if (!maxAge) return;
                const now = Date.now();
                this.queue = this.queue.filter(item => (now - item.serverTime) <= maxAge);
            }

            async drainQueue() {
                if (this.isDraining) return;
                this.isDraining = true;
                try {
                    while (this.queue.length > 0) {
                        if (document.visibilityState === 'hidden') {
                            await new Promise(r => setTimeout(r, 250));
                            continue;
                        }

                        this.dropExpiredInQueue();
                        if (this.queue.length === 0) break;

                        const unlimited = !!this.renderConfig.unlimitedDispatch;
                        const interval = Number(this.renderConfig.minDispatchIntervalMs || 0);
                        if (!unlimited && interval > 0) {
                            const elapsed = Date.now() - this.lastDispatchAt;
                            const wait = interval - elapsed;
                            if (wait > 0) {
                                await new Promise(r => setTimeout(r, Math.min(wait, 50)));
                                continue;
                            }
                        }

                        const item = this.queue.shift();
                        if (!item) break;
                        this.addSubtitle(item.text, item.config);
                        this.lastDispatchAt = Date.now();

                        // 让出事件循环，避免长时间占用主线程
                        await new Promise(r => setTimeout(r, 0));
                    }
                } finally {
                    this.isDraining = false;
                }
            }

            clearAll() {
                this.activeSubtitles.forEach(element => {
                    element.remove();
                });
                this.activeSubtitles.clear();
            }

            // SSE连接方法
            connectSSE(url = '/api/sse') {
                if (this.eventSource) {
                    this.disconnectSSE();
                }
                
                try {
                    this.eventSource = new EventSource(url);
                    
                    this.eventSource.onopen = () => {
                        console.log('SSE连接成功');
                    };
                    
                    this.eventSource.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleSSEMessage(data);
                        } catch (error) {
                            console.error('解析SSE消息失败:', error);
                        }
                    };
                    
                    this.eventSource.onerror = (error) => {
                        console.error('SSE连接错误:', error);
                        
                        // 自动重连
                        setTimeout(() => {
                            if (this.eventSource?.readyState === EventSource.CLOSED) {
                                this.connectSSE(url);
                            }
                        }, 3000);
                    };
                } catch (error) {
                    console.error('SSE连接失败:', error);
                }
            }

            disconnectSSE() {
                if (this.eventSource) {
                    this.eventSource.close();
                    this.eventSource = null;
                }
            }

            // 强制断开连接的方法
            forceDisconnectSSE() {
                if (this.eventSource) {
                    this.eventSource.close();
                    this.eventSource = null;
                }
                // 清理 all timers and event listeners
            }

            handleSSEMessage(data) {
                switch (data.type) {
                    case 'danmu':
                    case 'subtitle':
                    case 'text':
                        this.processDanmuData(data);
                        break;
                    case 'config':
                        this.updateConfig(data.config);
                        this.updateRenderConfig(data.render);
                        break;
                    case 'ping':
                        // Ping message for connection health
                        break;
                    default:
                        // 默认处理文本内容
                        if (data.text) {
                            this.processDanmuData(data);
                        }
                        break;
                }
            }

            processDanmuData(data) {
                if (DEBUG) console.log('Processing danmu data:', data);
                
                const config = {
                    fontSize: data.fontSize || data.size || this.defaultConfig.fontSize,
                    fontFamily: data.fontFamily || this.defaultConfig.fontFamily,
                    textColor: data.color || data.textColor || this.defaultConfig.textColor,
                    strokeColor: data.strokeColor || data.stroke_color || this.defaultConfig.strokeColor,
                    strokeWidth: data.strokeWidth || data.stroke_width || this.defaultConfig.strokeWidth,
                    typingSpeed: data.typingSpeed || data.typing_speed || this.defaultConfig.typingSpeed,
                    displayDuration: data.displayDuration || data.display_duration || this.defaultConfig.displayDuration,
                    fadeDuration: data.fadeDuration || data.fade_duration || this.defaultConfig.fadeDuration,
                    shakeAmplitude: data.shakeAmplitude || data.shake_amplitude || this.defaultConfig.shakeAmplitude,
                    randomTilt: data.randomTilt || data.random_tilt || this.defaultConfig.randomTilt
                };

                const text = data.text || data.content || data.message;
                const serverTime = typeof data.time === 'number' ? data.time : Date.now();
                this.enqueueDanmu(text, config, { serverTime });
            }
        }

        // 创建全局实例
        const subtitleSystem = new AdvancedSubtitleSystem();

        // 页面加载完成后自动连接SSE
        window.addEventListener('load', function() {
            const params = new URLSearchParams(window.location.search);
            const queryToken = params.get('token');

            // 如果 URL 带 token，写入 localStorage（同 origin 下后续可复用）
            if (queryToken) {
                try {
                    localStorage.setItem('yjdanmu.sseToken', queryToken);
                } catch (_) {}
            }

            let token = queryToken;
            if (!token) {
                try {
                    token = localStorage.getItem('yjdanmu.sseToken');
                } catch (_) {
                    token = null;
                }
            }

            const sseUrl = token ? `/api/sse?token=${encodeURIComponent(token)}` : '/api/sse';
            subtitleSystem.connectSSE(sseUrl);
        });
        
        // 页面卸载前断开SSE连接
        window.addEventListener('beforeunload', function() {
            if (subtitleSystem && subtitleSystem.forceDisconnectSSE) {
                subtitleSystem.forceDisconnectSSE();
            }
        });
        
        // 页面隐藏时不要断开连接，而是保持连接
        window.addEventListener('pagehide', function() {
            // 在页面隐藏时保持SSE连接，让浏览器处理后台连接
            if (DEBUG) console.log('页面隐藏，保持SSE连接');
        });
        
        // 页面可见性变化时处理连接
        document.addEventListener('visibilitychange', function() {
            if (document.visibilityState === 'hidden') {
                // 页面进入后台时，保持连接，不主动断开
                if (DEBUG) console.log('页面进入后台，保持SSE连接');
            } else if (document.visibilityState === 'visible' && subtitleSystem) {
                // 页面回到前台时，检查连接状态，如果断开则重新连接
                if (!subtitleSystem.eventSource || subtitleSystem.eventSource.readyState === EventSource.CLOSED) {
                    if (DEBUG) console.log('页面回到前台，重新连接SSE');
                    const params = new URLSearchParams(window.location.search);
                    const queryToken = params.get('token');
                    let token = queryToken;
                    if (!token) {
                        try {
                            token = localStorage.getItem('yjdanmu.sseToken');
                        } catch (_) {
                            token = null;
                        }
                    }
                    const sseUrl = token ? `/api/sse?token=${encodeURIComponent(token)}` : '/api/sse';
                    subtitleSystem.connectSSE(sseUrl);
                } else {
                    if (DEBUG) console.log('页面回到前台，SSE连接正常');
                }

                // 切回前台：可选丢弃过期积压，并继续 drain
                if (subtitleSystem.renderConfig?.dropOnResume) {
                    subtitleSystem.dropExpiredInQueue();
                }
                subtitleSystem.drainQueue();
            }
        });

        // 暴露接口给外部使用
        window.subtitleSystem = subtitleSystem;
    </script>
</body>
</html>